#!/usr/bin/env python3
"""
Real-time Vulnerability Monitoring System for Claude 3.7

This script implements a real-time monitoring system that can detect potential
vulnerabilities during live Claude 3.7 usage, providing immediate alerts and logging.
Features:
1. Websocket streaming of responses for real-time analysis
2. Pattern-based vulnerability detection
3. Integration with existing test suites for known vulnerability patterns
4. Alert system for immediate notification
5. Comprehensive logging for further analysis
"""

import argparse
import asyncio
import json
import os
import sys
import time
import re
import logging
import websockets
from typing import Dict, List, Any, Optional, Set, Tuple
import datetime
import pandas as pd
from collections import defaultdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_monitor.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("vulnerability_monitor")

class RealTimeVulnerabilityMonitor:
    """
    A real-time monitoring system for detecting vulnerabilities in Claude 3.7
    responses during live usage.
    """
    
    def __init__(self, config_path: str = "monitor_config.json"):
        """Initialize the monitor with configuration settings."""
        self.config_path = config_path
        self.config = self._load_config()
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.active_conversations = {}
        self.alert_history = []
        self.detection_stats = defaultdict(int)
        self.last_report_time = datetime.datetime.now()
        self.report_interval = datetime.timedelta(minutes=self.config.get("report_interval_minutes", 15))
        
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration settings from JSON file."""
        default_config = {
            "alert_threshold": 0.7,  # Confidence threshold for vulnerability alerts
            "max_conversation_history": 20,  # Max turns to keep in memory per conversation
            "report_interval_minutes": 15,  # Generate reports every X minutes
            "websocket_port": 8765,  # Port for websocket server
            "alert_channels": ["console", "log", "webhook"],  # Alert output channels
            "webhook_url": "",  # URL for webhook alerts
            "vulnerability_pattern_paths": [  # Paths to vulnerability pattern files
                "advanced_vulnerability_test_suite.json",
                "vulnerability_patterns.json"
            ]
        }
        
        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                # Merge with defaults
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value
                return config
            except Exception as e:
                logger.error(f"Error loading config: {e}")
                return default_config
        else:
            # Create default config file
            try:
                with open(self.config_path, 'w') as f:
                    json.dump(default_config, f, indent=2)
            except Exception as e:
                logger.error(f"Error creating default config: {e}")
            return default_config
    
    def _load_vulnerability_patterns(self) -> List[Dict[str, Any]]:
        """Load vulnerability patterns from test suites and pattern files."""
        patterns = []
        
        for pattern_path in self.config.get("vulnerability_pattern_paths", []):
            if os.path.exists(pattern_path):
                try:
                    with open(pattern_path, 'r') as f:
                        data = json.load(f)
                        
                    if "test_cases" in data:
                        # Extract patterns from test suite format
                        for test in data["test_cases"]:
                            if "success_criteria" in test:
                                pattern = {
                                    "id": test.get("vulnerability_id", "UNKNOWN"),
                                    "title": test.get("title", "Unknown Vulnerability"),
                                    "category": test.get("category", ["Unknown"]),
                                    "severity": test.get("severity", "Medium"),
                                    "indicators": test.get("success_criteria", []),
                                    "regex_patterns": self._compile_indicators(test.get("success_criteria", [])),
                                    "source": pattern_path
                                }
                                patterns.append(pattern)
                    elif "patterns" in data:
                        # Direct pattern format
                        patterns.extend(data["patterns"])
                except Exception as e:
                    logger.error(f"Error loading patterns from {pattern_path}: {e}")
        
        # Compile regex patterns if not already compiled
        for pattern in patterns:
            if "regex_patterns" not in pattern and "indicators" in pattern:
                pattern["regex_patterns"] = self._compile_indicators(pattern["indicators"])
                
        logger.info(f"Loaded {len(patterns)} vulnerability patterns")
        return patterns
    
    def _compile_indicators(self, indicators: List[str]) -> List[Any]:
        """Compile indicator strings into regex patterns."""
        regex_patterns = []
        for indicator in indicators:
            try:
                # Make the regex more flexible with word boundaries and case insensitivity
                pattern = r'\b' + re.escape(indicator).replace(r'\ ', r'\s+') + r'\b'
                regex_patterns.append(re.compile(pattern, re.IGNORECASE))
            except Exception as e:
                logger.error(f"Error compiling regex for '{indicator}': {e}")
        return regex_patterns
    
    def analyze_response(self, conversation_id: str, user_message: str, model_response: str) -> List[Dict[str, Any]]:
        """
        Analyze a model response for potential vulnerabilities.
        
        Returns a list of detected vulnerabilities with confidence scores.
        """
        # Update conversation history
        if conversation_id not in self.active_conversations:
            self.active_conversations[conversation_id] = []
            
        # Add the new turn
        self.active_conversations[conversation_id].append({
            "user": user_message,
            "model": model_response,
            "timestamp": datetime.datetime.now().isoformat()
        })
        
        # Trim conversation history if needed
        if len(self.active_conversations[conversation_id]) > self.config.get("max_conversation_history", 20):
            self.active_conversations[conversation_id] = self.active_conversations[conversation_id][-self.config.get("max_conversation_history", 20):]
        
        # Check for vulnerabilities
        detections = []
        conversation_context = "\n".join([
            f"USER: {turn['user']}\nMODEL: {turn['model']}" 
            for turn in self.active_conversations[conversation_id]
        ])
        
        for pattern in self.vulnerability_patterns:
            # Initialize detection scoring
            match_count = 0
            total_indicators = len(pattern.get("regex_patterns", []))
            
            if total_indicators == 0:
                continue
                
            # Check each regex pattern
            for regex in pattern.get("regex_patterns", []):
                if regex.search(model_response):
                    match_count += 1
            
            # Calculate confidence score
            if match_count > 0:
                confidence = match_count / total_indicators
                
                # If confidence exceeds threshold, record the detection
                if confidence >= self.config.get("alert_threshold", 0.7):
                    detection = {
                        "vulnerability_id": pattern.get("id", "UNKNOWN"),
                        "title": pattern.get("title", "Unknown Vulnerability"),
                        "category": pattern.get("category", ["Unknown"]),
                        "severity": pattern.get("severity", "Medium"),
                        "confidence": confidence,
                        "matched_indicators": match_count,
                        "total_indicators": total_indicators,
                        "timestamp": datetime.datetime.now().isoformat(),
                        "conversation_id": conversation_id
                    }
                    detections.append(detection)
                    
                    # Update statistics
                    self.detection_stats[pattern.get("id", "UNKNOWN")] += 1
                    
                    # Log the detection
                    self._handle_alert(detection, model_response)
        
        # Check if it's time for a periodic report
        now = datetime.datetime.now()
        if now - self.last_report_time >= self.report_interval:
            self._generate_periodic_report()
            self.last_report_time = now
            
        return detections
    
    def _handle_alert(self, detection: Dict[str, Any], model_response: str):
        """Handle a vulnerability alert according to configured alert channels."""
        # Add to alert history
        self.alert_history.append(detection)
        
        # Prepare alert message
        alert_msg = (
            f"VULNERABILITY ALERT: {detection['title']} ({detection['vulnerability_id']})\n"
            f"Severity: {detection['severity']}\n"
            f"Confidence: {detection['confidence']:.2f}\n"
            f"Category: {', '.join(detection['category'])}\n"
            f"Conversation ID: {detection['conversation_id']}\n"
            f"Timestamp: {detection['timestamp']}"
        )
        
        # Send alerts to configured channels
        for channel in self.config.get("alert_channels", ["console"]):
            if channel == "console":
                print("\n" + "!" * 80)
                print(alert_msg)
                print("!" * 80 + "\n")
            
            elif channel == "log":
                logger.warning(alert_msg)
                logger.warning(f"Response excerpt: {model_response[:200]}...")
            
            elif channel == "webhook" and self.config.get("webhook_url"):
                # Send webhook alert (implementation would depend on your webhook service)
                # This is a placeholder for actual webhook implementation
                pass
    
    def _generate_periodic_report(self):
        """Generate a periodic report of vulnerability detections."""
        if not self.detection_stats:
            logger.info("No vulnerabilities detected in the current reporting period.")
            return
            
        # Prepare report
        report = {
            "period_start": self.last_report_time.isoformat(),
            "period_end": datetime.datetime.now().isoformat(),
            "total_detections": sum(self.detection_stats.values()),
            "detection_by_vulnerability": dict(self.detection_stats),
            "recent_alerts": self.alert_history[-10:] if self.alert_history else []
        }
        
        # Log report summary
        logger.info(f"Vulnerability Report ({report['period_start']} to {report['period_end']})")
        logger.info(f"Total detections: {report['total_detections']}")
        
        # Save detailed report to file
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        report_path = f"reports/vulnerability_report_{timestamp}.json"
        
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        try:
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)
            logger.info(f"Detailed report saved to {report_path}")
        except Exception as e:
            logger.error(f"Error saving report: {e}")
    
    async def start_websocket_server(self):
        """Start a WebSocket server to receive and analyze conversations in real-time."""
        
        async def handler(websocket, path):
            logger.info(f"New connection established: {path}")
            
            try:
                async for message in websocket:
                    try:
                        data = json.loads(message)
                        
                        # Process the incoming conversation data
                        if "conversation_id" in data and "user_message" in data and "model_response" in data:
                            # Analyze for vulnerabilities
                            detections = self.analyze_response(
                                data["conversation_id"],
                                data["user_message"],
                                data["model_response"]
                            )
                            
                            # Send back detection results
                            await websocket.send(json.dumps({
                                "status": "ok",
                                "detections": detections,
                                "timestamp": datetime.datetime.now().isoformat()
                            }))
                        else:
                            await websocket.send(json.dumps({
                                "status": "error",
                                "message": "Missing required fields: conversation_id, user_message, model_response",
                                "timestamp": datetime.datetime.now().isoformat()
                            }))
                            
                    except json.JSONDecodeError:
                        await websocket.send(json.dumps({
                            "status": "error",
                            "message": "Invalid JSON format",
                            "timestamp": datetime.datetime.now().isoformat()
                        }))
                        
            except websockets.exceptions.ConnectionClosed:
                logger.info("Connection closed")
        
        # Start WebSocket server
        port = self.config.get("websocket_port", 8765)
        logger.info(f"Starting WebSocket server on port {port}")
        
        async with websockets.serve(handler, "localhost", port):
            await asyncio.Future()  # Run forever
    
    def export_patterns_to_test_suite(self, output_path: str):
        """Export the current vulnerability patterns as a test suite."""
        test_suite = {
            "name": "Auto-Generated Vulnerability Test Suite",
            "description": "Test cases generated from real-time vulnerability monitor patterns",
            "version": "1.0",
            "created": datetime.datetime.now().isoformat(),
            "test_cases": []
        }
        
        for pattern in self.vulnerability_patterns:
            # Convert pattern to test case format
            test_case = {
                "vulnerability_id": pattern.get("id", "UNKNOWN"),
                "title": pattern.get("title", "Unknown Vulnerability"),
                "category": pattern.get("category", ["Unknown"]),
                "severity": pattern.get("severity", "Medium"),
                "test_case": f"Verify vulnerability {pattern.get('id', 'UNKNOWN')}: {pattern.get('title', 'Unknown Vulnerability')}",
                "success_criteria": pattern.get("indicators", []),
                "source": "auto-generated"
            }
            
            test_suite["test_cases"].append(test_case)
        
        # Write to file
        try:
            with open(output_path, 'w') as f:
                json.dump(test_suite, f, indent=2)
            logger.info(f"Exported {len(test_suite['test_cases'])} test cases to {output_path}")
            return True
        except Exception as e:
            logger.error(f"Error exporting test suite: {e}")
            return False
        
    def import_vulnerabilities_from_test_results(self, results_path: str):
        """Import new vulnerability patterns from test results."""
        try:
            with open(results_path, 'r') as f:
                results = json.load(f)
                
            new_patterns = []
            
            # Process test results to extract vulnerability patterns
            if "test_results" in results:
                for result in results["test_results"]:
                    if result.get("vulnerability_detected"):
                        # Extract new pattern from successful vulnerability test
                        pattern = {
                            "id": result.get("vulnerability_id", "UNKNOWN"),
                            "title": result.get("title", "Unknown Vulnerability"),
                            "category": result.get("category", ["Unknown"]),
                            "severity": result.get("severity", "Medium"),
                            "indicators": result.get("detected_indicators", []),
                            "source": results_path
                        }
                        
                        # Compile regex patterns
                        pattern["regex_patterns"] = self._compile_indicators(pattern["indicators"])
                        
                        new_patterns.append(pattern)
            
            # Add new patterns
            if new_patterns:
                self.vulnerability_patterns.extend(new_patterns)
                logger.info(f"Imported {len(new_patterns)} new vulnerability patterns from {results_path}")
                return len(new_patterns)
            else:
                logger.info(f"No new vulnerability patterns found in {results_path}")
                return 0
                
        except Exception as e:
            logger.error(f"Error importing vulnerabilities from {results_path}: {e}")
            return 0

    def save_vulnerability_patterns(self, output_path: str):
        """Save the current vulnerability patterns to a file."""
        patterns_output = {
            "name": "Claude 3.7 Vulnerability Patterns",
            "description": "Patterns for detecting Claude 3.7 vulnerabilities in real-time",
            "version": "1.0",
            "created": datetime.datetime.now().isoformat(),
            "patterns": []
        }
        
        for pattern in self.vulnerability_patterns:
            # Create serializable pattern (remove compiled regex)
            serialized_pattern = {k: v for k, v in pattern.items() if k != "regex_patterns"}
            patterns_output["patterns"].append(serialized_pattern)
        
        # Write to file
        try:
            with open(output_path, 'w') as f:
                json.dump(patterns_output, f, indent=2)
            logger.info(f"Saved {len(patterns_output['patterns'])} vulnerability patterns to {output_path}")
            return True
        except Exception as e:
            logger.error(f"Error saving vulnerability patterns: {e}")
            return False


async def main():
    """Main function to start the vulnerability monitor."""
    parser = argparse.ArgumentParser(description="Real-time vulnerability monitoring for Claude 3.7")
    parser.add_argument("--config", default="monitor_config.json", help="Path to configuration file")
    parser.add_argument("--export-patterns", help="Export vulnerability patterns as a test suite to the specified path")
    parser.add_argument("--import-results", help="Import new vulnerabilities from test results file")
    parser.add_argument("--save-patterns", help="Save vulnerability patterns to the specified path")
    parser.add_argument("--server", action="store_true", help="Start the WebSocket server for real-time monitoring")
    
    args = parser.parse_args()
    
    # Create the vulnerability monitor
    monitor = RealTimeVulnerabilityMonitor(config_path=args.config)
    
    # Handle command-line options
    if args.export_patterns:
        monitor.export_patterns_to_test_suite(args.export_patterns)
        
    if args.import_results:
        monitor.import_vulnerabilities_from_test_results(args.import_results)
        
    if args.save_patterns:
        monitor.save_vulnerability_patterns(args.save_patterns)
        
    if args.server:
        # Start the WebSocket server
        await monitor.start_websocket_server()
    
    # If no action specified, print help
    if not any([args.export_patterns, args.import_results, args.save_patterns, args.server]):
        parser.print_help()

if __name__ == "__main__":
    asyncio.run(main())
