#!/usr/bin/env python3
"""
Claude 4.0 API Client with Real-time Safeguards Enforcement

This script demonstrates how to integrate comprehensive safety monitoring
with Claude API usage, providing real-time policy enforcement, content
classification, and safety interventions to protect user well-being,
with particular attention to child safety concerns.
"""

import argparse
import asyncio
import json
import os
import sys
import time
import websockets
import uuid
from typing import Dict, List, Any, Optional
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("monitor_client.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("monitor_client")

class VulnerabilityAwareClient:
    """
    A client for interacting with Claude 4.0 API while monitoring for vulnerabilities
    in real-time using WebSocket connection to the vulnerability monitor.
    """
    
    def __init__(self, api_key: str = None, websocket_url: str = "ws://localhost:8765"):
        """Initialize the client."""
        self.api_key = api_key or os.environ.get("ANTHROPIC_API_KEY")
        self.websocket_url = websocket_url
        self.websocket = None
        self.conversation_id = str(uuid.uuid4())
        self.conversation_history = []
        
        # Import Anthropic client conditionally
        try:
            from anthropic import Anthropic
            self.anthropic = Anthropic(api_key=self.api_key)
            self.api_available = True
        except ImportError:
            logger.warning("Anthropic API client not available. Running in simulation mode.")
            self.anthropic = None
            self.api_available = False
    
    async def connect_to_monitor(self):
        """Connect to the vulnerability monitor WebSocket server."""
        try:
            self.websocket = await websockets.connect(self.websocket_url)
            logger.info(f"Connected to vulnerability monitor at {self.websocket_url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to vulnerability monitor: {e}")
            self.websocket = None
            return False
    
    async def close_monitor_connection(self):
        """Close the WebSocket connection to the vulnerability monitor."""
        if self.websocket:
            await self.websocket.close()
            logger.info("Closed connection to vulnerability monitor")
    
    async def send_to_monitor(self, user_message: str, model_response: str):
        """Send a conversation turn to the vulnerability monitor for analysis."""
        if not self.websocket:
            logger.warning("Not connected to vulnerability monitor")
            return None
            
        try:
            # Prepare data for the monitor
            data = {
                "conversation_id": self.conversation_id,
                "user_message": user_message,
                "model_response": model_response,
                "timestamp": time.time()
            }
            
            # Send to monitor
            await self.websocket.send(json.dumps(data))
            
            # Wait for response from monitor
            response = await self.websocket.recv()
            return json.loads(response)
        
        except Exception as e:
            logger.error(f"Error communicating with vulnerability monitor: {e}")
            return None
    
    async def get_completion(self, prompt: str, model: str = "claude-4-sonnet-20240520") -> str:
        """
        Get a completion from Claude 4.0 API and send it to the vulnerability monitor.
        
        Args:
            prompt: The user message to send to Claude
            model: The model version to use (default: claude-4-sonnet-20240520)
            
        Returns:
            The model's response
        """
        # Add to conversation history
        self.conversation_history.append({
            "role": "user",
            "content": prompt
        })
        
        # Get response from API or simulate one
        if self.api_available and self.anthropic:
            try:
                # Call Anthropic API
                response = self.anthropic.messages.create(
                    model=model,
                    max_tokens=1024,
                    messages=self.conversation_history
                )
                
                model_response = response.content[0].text
                
            except Exception as e:
                logger.error(f"Error calling Anthropic API: {e}")
                model_response = f"[API ERROR: {str(e)}]"
        else:
            # Simulate a response for testing
            logger.info("Simulating Claude response (API not available)")
            model_response = f"This is a simulated response for testing the vulnerability monitor. Your prompt was: {prompt[:50]}..."
        
        # Add response to conversation history
        self.conversation_history.append({
            "role": "assistant",
            "content": model_response
        })
        
        # Send to vulnerability monitor if connected
        if self.websocket:
            monitor_result = await self.send_to_monitor(prompt, model_response)
            
            # Check if vulnerabilities were detected
            if monitor_result and "detections" in monitor_result and monitor_result["detections"]:
                logger.warning(f"VULNERABILITY DETECTED: {len(monitor_result['detections'])} potential issues found")
                
                for detection in monitor_result["detections"]:
                    logger.warning(f"  - {detection['title']} (ID: {detection['vulnerability_id']})")
                    logger.warning(f"    Severity: {detection['severity']}, Confidence: {detection['confidence']:.2f}")
                    
        return model_response
    
    async def interactive_session(self, model: str = "claude-4-sonnet-20240520"):
        """Run an interactive session with Claude 4.0 with real-time vulnerability monitoring."""
        print(f"\n{'=' * 80}\nStarting Interactive Session with {model}\n{'=' * 80}")
        print("Type 'exit' or 'quit' to end the session\n")
        
        # Connect to vulnerability monitor
        monitor_connected = await self.connect_to_monitor()
        if not monitor_connected:
            print("Warning: Not connected to vulnerability monitor. Proceeding without vulnerability detection.")
        
        try:
            while True:
                # Get user input
                user_input = input("\nYou: ")
                
                # Check for exit command
                if user_input.lower() in ["exit", "quit"]:
                    break
                
                # Get and display response
                print("\nClaude: ", end="", flush=True)
                
                response = await self.get_completion(user_input, model)
                print(response)
        
        finally:
            # Close monitor connection
            await self.close_monitor_connection()


async def main():
    """Main function."""
    parser = argparse.ArgumentParser(description="Claude 4.0 API Client with Vulnerability Monitoring")
    parser.add_argument("--api-key", help="Anthropic API key (or set ANTHROPIC_API_KEY environment variable)")
    parser.add_argument("--monitor-url", default="ws://localhost:8765", help="WebSocket URL for vulnerability monitor")
    parser.add_argument("--model", default="claude-4-sonnet-20240520", help="Model to use for completions")
    parser.add_argument("--prompt", help="Single prompt to send (if not specified, runs interactive session)")
    
    args = parser.parse_args()
    
    # Create client
    client = VulnerabilityAwareClient(api_key=args.api_key, websocket_url=args.monitor_url)
    
    # Connect to monitor
    connected = await client.connect_to_monitor()
    if not connected and not args.prompt:
        print("Failed to connect to vulnerability monitor. Would you like to proceed without monitoring? (y/n)")
        response = input().lower()
        if response != "y":
            print("Exiting...")
            return
    
    try:
        if args.prompt:
            # Single prompt mode
            response = await client.get_completion(args.prompt, args.model)
            print(f"\nClaude: {response}")
        else:
            # Interactive mode
            await client.interactive_session(args.model)
    
    finally:
        # Close connection
        await client.close_monitor_connection()

if __name__ == "__main__":
    asyncio.run(main())
